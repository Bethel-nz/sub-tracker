import { getContractFactory } from '@nomicfoundation/hardhat-ethers/types';
import { ethers } from 'hardhat';
import { beforeEach, describe } from 'mocha';
import { SubTracker__factory } from './../typechain-types/factories/SubTracker__factory';
import { SubTracker } from '../typechain-types';
import { assert, expect } from 'chai';

describe('SubTracker', function () {
  let INITIAL_PRICE = 1;
  let SUBSCRIPTION_DURATION = 2419200;
  let SubTrackerFactory: SubTracker__factory;
  let SubTracker: SubTracker;
  beforeEach(async function () {
    SubTrackerFactory = await ethers.getContractFactory('SubTracker');
    SubTracker = await SubTrackerFactory.deploy(
      INITIAL_PRICE,
      SUBSCRIPTION_DURATION
    );
  });
  it('Should allow a user to subscribe', async function () {
    const addressToSubscribe = '0xf39fd6e51aad88f6f4ce6ab8827279cfffb92266'; // Replace with a test address
    await SubTracker.subscribe({ value: ethers.parseEther('1.0') });
    const isActive = await SubTracker.isActiveSubscriber(addressToSubscribe);
    assert.isTrue(isActive);
  });
  it('Should Set Subscription Price', async function () {
    const oldPrice = await SubTracker.subscriptionPrice();
    const newPrice = ethers.parseEther('0.05');

    await SubTracker.setSubscriptionPrice(newPrice);
    const currentPrice = await SubTracker.subscriptionPrice();

    assert.notEqual(currentPrice, oldPrice);
  });

  //This was generated by an AI
  it('Should return correct list and count of inactive subscribers', async function () {
    const [_, subscriber1, subscriber2] = await ethers.getSigners();
    await SubTracker.connect(subscriber1).subscribe({
      value: ethers.parseEther('1'),
    });

    ethers.provider.send('evm_increaseTime', [SUBSCRIPTION_DURATION + 10]);
    await ethers.provider.send('evm_mine');

    await SubTracker.connect(subscriber2).subscribe({
      value: ethers.parseEther('1'),
    });

    const inactiveSubscribers = await SubTracker.getInactiveSubscribers();

    assert.equal(inactiveSubscribers.length, 1);
    assert.isTrue(inactiveSubscribers.includes(subscriber1.address));
  });
  it('Should return expiry time for an active subscription', async function () {
    const [_, subscriber] = await ethers.getSigners();
    await SubTracker.connect(subscriber).subscribe({
      value: ethers.parseEther('1'),
    });

    const expiryTime = await SubTracker.connect(
      subscriber
    ).getSubscriptionExpiry(subscriber.address);

    let expectedExpiry =
      (await ethers.provider.getBlock('latest'))!.timestamp +
      SUBSCRIPTION_DURATION;
    assert.approximately(Number(expiryTime), expectedExpiry, 10);
  });
  it('Should return 0 for no subscriptions', async function () {
    const totalSubscribers = await SubTracker.getTotalSubscribers();
    assert.equal(Number(totalSubscribers), 0);
  });

  it('Should return correct count with multiple subscriptions', async function () {
    const [_, subscriber1, subscriber2] = await ethers.getSigners();
    await SubTracker.connect(subscriber1).subscribe({
      value: ethers.parseEther('1'),
    });

    await SubTracker.connect(subscriber2).subscribe({
      value: ethers.parseEther('1'),
    });

    ethers.provider.send('evm_increaseTime', [SUBSCRIPTION_DURATION + 10]);
    await ethers.provider.send('evm_mine');

    const totalSubscribers = await SubTracker.getTotalSubscribers();
    assert.equal(Number(totalSubscribers), 2);
  });

  it('Should return a list of all active subscribers', async function () {
    const [_, subscriber1, subscriber2] = await ethers.getSigners();
    await SubTracker.connect(subscriber1).subscribe({
      value: ethers.parseEther('1'),
    });

    ethers.provider.send('evm_increaseTime', [SUBSCRIPTION_DURATION + 10]);
    await ethers.provider.send('evm_mine');

    const activeSubscribers = await SubTracker.getTotalActiveSubscribers();

    assert.equal(Number(activeSubscribers), 1);
  });

  it('Should return empty array for no subscriptions', async function () {
    const [_, subscriber1, subscriber2, subscriber3] =
      await ethers.getSigners();

    await SubTracker.connect(subscriber1).subscribe({
      value: ethers.parseEther('1'),
    });
    await SubTracker.connect(subscriber2).subscribe({
      value: ethers.parseEther('1'),
    });

    ethers.provider.send('evm_increaseTime', [SUBSCRIPTION_DURATION + 10]);
    await ethers.provider.send('evm_mine');
    SubTracker = await SubTrackerFactory.deploy(
      INITIAL_PRICE,
      SUBSCRIPTION_DURATION
    );

    const allSubscribers = await SubTracker.getAllSubscribers();
    assert.isEmpty(allSubscribers);
  });

  it('Should return all subscribers (active and inactive)', async function () {
    const [_, subscriber1, subscriber2, subscriber3] =
      await ethers.getSigners();

    await SubTracker.connect(subscriber1).subscribe({
      value: ethers.parseEther('1'),
    });
    await SubTracker.connect(subscriber2).subscribe({
      value: ethers.parseEther('1'),
    });
    await SubTracker.connect(subscriber3).subscribe({
      value: ethers.parseEther('1'),
    });

    ethers.provider.send('evm_increaseTime', [SUBSCRIPTION_DURATION + 10]);
    await ethers.provider.send('evm_mine');

    const allSubscribers = await SubTracker.getAllSubscribers();

    assert.equal(allSubscribers.length, 3);
    assert.isTrue(allSubscribers.includes(subscriber1.address));
    assert.isTrue(allSubscribers.includes(subscriber2.address));
    assert.isTrue(allSubscribers.includes(subscriber3.address));
  });
  it('Should return correct count of inactive subscribers', async function () {
    const [_, subscriber1, subscriber2] = await ethers.getSigners();

    await SubTracker.connect(subscriber1).subscribe({
      value: ethers.parseEther('1'),
    });
    await SubTracker.connect(subscriber2).subscribe({
      value: ethers.parseEther('1'),
    });
    ethers.provider.send('evm_increaseTime', [SUBSCRIPTION_DURATION + 100]);
    await ethers.provider.send('evm_mine');

    const inactiveSubscribersCount =
      await SubTracker.getTotalInactiveSubscribers();

    assert.isAbove(Number(inactiveSubscribersCount), -1);
  });
  it('Should expire active subscriptions past their expiry date', async function () {
    const [_, subscriber1] = await ethers.getSigners();

    await SubTracker.connect(subscriber1).subscribe({
      value: ethers.parseEther('1'),
    });

    ethers.provider.send('evm_increaseTime', [SUBSCRIPTION_DURATION + 10]);
    await ethers.provider.send('evm_mine');

    await SubTracker.expireSubscriptions();

    const isSubscriber1Active = await SubTracker.isActiveSubscriber(
      subscriber1.address
    );

    assert.isFalse(isSubscriber1Active);
  });
  it('Should allow the owner to withdraw the contract balance', async function () {
    const [owner, subscriber1] = await ethers.getSigners();

    await SubTracker.connect(subscriber1).subscribe({
      value: ethers.parseEther('1'),
    });

    const initialContractBalance = await ethers.provider.getBalance(
      SubTracker.getAddress()
    );

    await SubTracker.withDraw();
    const newContractBalance = await ethers.provider.getBalance(
      SubTracker.getAddress()
    );
    assert.isAbove(Number(initialContractBalance), Number(newContractBalance));
  });

  it('Should prevent non-owners from withdrawing', async function () {
    const [_, subscriber1] = await ethers.getSigners();

    await SubTracker.connect(subscriber1).subscribe({
      value: ethers.parseEther('1'),
    });

    await expect(
      SubTracker.connect(subscriber1).withDraw()
    ).to.be.revertedWithCustomError(SubTracker, 'NotOwner');
  });
});
